#!/usr/bin/env python

# A bag contains one red disc and one blue disc. In a game of chance a player
# takes a disc at random and its colour is noted. After each turn the disc is
# returned to the bag, an extra red disc is added, and another disc is
# taken at random.

# The player... wins if they have taken more blue discs than red discs a
# the end of the game.

################################################################################
# P_n = prob(disc n is blue) = 1/(n + 1)

# For n discs, let C_1-C_2-...-C_n be the colors drawn, let i_1,...,i_k be the
# indices j such that disk i_j was drawn red. The probability of this event
# is (i_1 * ... * i_k)/factorial(n + 1)

from python_code.decorators import euler_timer
from python_code.functions import all_permutations

def possible_draws(blue, red):
    choices = list(("B" * blue) + ("R" * red))
    return all_permutations(choices)

def numerator_from_draw(draw):
    n = len(draw)
    # choice i is index i-1
    product = 1
    for i in range(1, n + 1):
        if draw[i-1] == "R":
            product *= i
    return product

def all_blue_winning_draws(n):
    # intended to be integer division
    min_blue = (n/2) + 1
    draws = []
    for blue in range(min_blue, n + 1):
        draws.extend(possible_draws(blue, n - blue))
    return sum([ numerator_from_draw(draw) for draw in draws ])

# We can enumeratively define n_{j,k} to be the aggregate numerator
# of all possible draws with j blues drawn out of k draws
#
# The initial conditions are n_{0,1} = 1, n_{1,1} = 1
# The recurrence is defined by the fact that the n_{j + 1,k + 1} is
# can only have the (k + 1)'st element be blue or red, hence
# n_{j + 1,k + 1} = numer(blue)*n_{j,k} + numer(red)*n_{j + 1,k}
#                 = n_{j,k} + (k + 1)*n_{j + 1,k}
# except for the cases j = k, where n_{j,k} = numer(all blue) = 1
# except for the cases j = 0, where n_{0,k} = k!

def iterative_numerator(n):
    from math import factorial
    numerators = {}
    for k in range(1,n + 1):
        for j in range(k + 1):
            if j == 0:
                numerators[(j,k)] = factorial(k)
            elif j == k:
                numerators[(j,k)] = 1
            else:
                numerators[(j,k)] = numerators[(j - 1,k - 1)] + \
                                    k*numerators[(j,k - 1)]
    min_blue = (n/2) + 1
    count = 0
    for blue in range(min_blue, n + 1):
        count += numerators[(blue, n)]
    return count

def max_payout(n):
    from math import factorial
    # Integer division precludes floor operation
    return factorial(n + 1)/iterative_numerator(n)

@euler_timer(121)
def main():
    print max_payout(15)

if __name__ == "__main__":
    main()
