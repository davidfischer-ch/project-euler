#!/usr/bin/env python

# It can be verified that there are 23 positive integers less
# than 1000 that are divisible by at least four distinct primes
# less than 100.

# Find how many positive integers less than 10**16 are divisible
# by at least four distinct primes less than 100.


######################
# The biggest primes under 100 are 79, 83, 89, 97 and they have
# product 56606581 which is less than 10**16

# We will count this via a contrived form of PIE
# 798000 is divisible by (2,3,5,7) but also by 19 hence it would
# be included in 5 different sets (just considering numbers
# which are multiples of p1, p2, p3 and p4 (which end up being
# exactly those numbers which are multiples of p1*p2*p3*p4)

# EXAMPLE:
# Compute the number if integers less than 10000 that are divisible by
# four out of 2, 3, 5, 7 and 11

# 2,3,5,7 = 210 --> 47 multiples
# 2,3,5,11 = 330 --> 30 multiples
# 2,3,7,11 = 462 --> 21 multiples
# 2,5,7,11 = 770 --> 12 multiples
# 3,5,7,11 = 1155 --> 8 multiples
# 2,3,5,7,11 = 2310 --> 4 multiples

# We have 47 + 30 + 21 + 12 + 8 = 118 total multiples, but
# 4 multiples get double counted at the intersection of (2,3,5,7) and
# (2,3,5,11), 4 get double counted at the intersection of (2,3,5,7) and
# (2,3,7,11), so we must subtract its value from all the lists it
# is contained in which gives us 118 - 5*4 = 98 unique to those lists
# with 4 more in the 2,3,5,7,11 list for a total of 102

# subs = all_subsets([2, 3, 5, 7, 11, 13, 17], 4)
# def f(n):
#     for sub in subs:
#         if reduce(operator.and_, [n % prime == 0 for prime in sub]):
#             return True
#     return False
# val = len([x for x in range(1,1000000) if f(x)]) # 1661

# nines = 999999
# primes = [2, 3, 5, 7, 11, 13, 17]
# count = 0
# index = 4
# sign = 1
# result = []
# for sub in all_subsets(primes, index):
#     product = reduce(operator.mul, sub)
#     result.append(nines/product)
# count += sign*(factorial(index-1)/(factorial(3)*factorial(index-4)))*sum(result)
# index += 1
# sign = -sign
# result = []
# for sub in all_subsets(primes, index):
#     product = reduce(operator.mul, sub)
#     result.append(nines/product)
# count += sign*(factorial(index-1)/(factorial(3)*factorial(index-4)))*sum(result)
# index += 1
# sign = -sign
# result = []
# for sub in all_subsets(primes, index):
#     product = reduce(operator.mul, sub)
#     result.append(nines/product)
# count += sign*(factorial(index-1)/(factorial(3)*factorial(index-4)))*sum(result)
# index += 1
# sign = -sign
# result = []
# for sub in all_subsets(primes, index):
#     product = reduce(operator.mul, sub)
#     result.append(nines/product)
# count += sign*(factorial(index-1)/(factorial(3)*factorial(index-4)))*sum(result)

import operator
from math import factorial

from python_code.decorators import euler_timer
from python_code.functions import all_subsets
from python_code.functions import sieve

def choose(n, k):
    return factorial(n)/(factorial(k)*factorial(n-k))

@euler_timer(268)
def main():
    PRIMES = sieve(100)
    value = 10**16
    count = 0
    index = 4
    sign = 1

    for index in range(4, len(PRIMES) + 1):
        set_sizes = []
        for subset in all_subsets(PRIMES, index):
            product = reduce(operator.mul, subset)
            set_sizes.append((value - 1)/product) # integer division
        count += sign*choose(index - 1, 3)*sum(set_sizes)
        sign = -sign

    print count

if __name__ == "__main__":
    print "The answer to Euler Project, question 268 is: 785478606870985\n\n" \
          "This solution ran in 1.742E3 seconds.\n" \
          "Due to runtime, this is not actually running."
